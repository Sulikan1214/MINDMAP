<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Cr√©er sa Carte Mentale ‚Äî Standalone (avec zoom/pan & drag)</title>
    <style>
        /* Base */
        * { box-sizing: border-box; margin:0; padding:0; }
        body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#222; min-height:100vh; padding:10px; }
        .container { max-width:1200px; margin:0 auto; }
        
        /* Header */
        .header{ color:white; text-align:center; margin-bottom:18px }
        .header p{ font-size:0.9em; opacity:0.8; }

        /* Layout */
        .layout{ display:grid; grid-template-columns:1fr 1fr; gap:18px; }
        .panel{ background:white; padding:16px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,0.12); }
        
        /* Inputs & Buttons */
        .input-group{ display:flex; gap:8px; margin-bottom:10px; flex-wrap: nowrap; }
        input[type=text], select { padding:8px; border-radius:8px; border:1px solid #eee; flex:1; min-width:80px; font-size:14px; }
        input[type=color]{ width:40px; height:40px; padding:4px; border-radius:8px; border:1px solid #ddd; flex:0 0 40px; }
        button { padding:8px 12px; border-radius:8px; border:none; background:#667eea; color:#fff; cursor:pointer; font-size:14px; white-space: nowrap; }
        .btn-secondary{ background:#f0f0f0; color:#333; }
        .btn-danger{ background:#ef4444; color:#fff; }

        /* Lists */
        .item-list{ max-height:260px; overflow:auto; display:flex; flex-direction:column; gap:8px; }
        .item-chip{ padding:8px; border-radius:8px; border:1px solid #eee; display:flex; justify-content:space-between; align-items:center; }
        .item-chip > div:first-child { flex: 1; overflow: hidden; }

        /* Canvas */
        #canvas-container{ background:#f8f9fa; border:2px dashed #667eea; border-radius:10px; min-height:520px; display:flex; align-items:center; justify-content:center; overflow:hidden; position:relative }
        canvas{ display:block; width:100%; height:100%; touch-action: none; }
        
        /* NOUVEAU: Contr√¥les Zoom/Pan */
        #canvas-controls {
            position: absolute;
            bottom: 15px; /* Ajustement pour la responsivit√© */
            right: 15px; /* Ajustement pour la responsivit√© */
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(102, 126, 234, 0.9); /* #667eea avec l√©g√®re opacit√© */
            color: white;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: background 0.2s;
            line-height: 1; /* Pour centrer le texte/symbole */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .control-btn:hover {
            background: rgba(84, 108, 216, 0.9);
        }
        
        /* Misc */
        .legend{ display:flex; gap:12px; margin-top:12px; flex-wrap: wrap; }
        .legend-item{ display:flex; align-items:center; gap:4px }
        .legend-dot{ width:12px; height:12px; border-radius:50%; }
        .message{ margin-top:10px; }
        .hint{ font-size:0.8em; color:#555; margin-top:8px }

        /* Dropdown */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; border-radius: 8px; overflow: hidden; right: 0; }
        .dropdown-content button { color: black; padding: 10px 12px; text-decoration: none; display: block; width: 100%; text-align: left; background: none; border: none; border-bottom: 1px solid #eee; border-radius: 0; }
        .dropdown-content button:hover { background-color: #f1f1f1; }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown-content button:last-child { border-bottom: none; }

        /* Responsive adjustments */
        @media (max-width: 1024px){ 
            .layout{ grid-template-columns:1fr; } 
            #canvas-container{ min-height:420px; height: 70vh; }
        }
        
        @media (max-width: 600px){ 
            body { padding: 8px; }
            .header h1 { font-size: 1.5em; }
            .header p { font-size: 0.8em; }
            .panel { padding: 12px; }
            .input-group{ flex-wrap: wrap; }
            .input-group input[type=text], .input-group select { flex: 1 1 45%; min-width: 45%; }
            .input-group button, .input-group input[type=color] { flex: 0 0 auto; }
            .item-chip div:nth-child(2) button { padding: 6px 10px; font-size: 12px; }
            .legend-item { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Atelier Carte Mentale</h1>
            <p>Sauvegarde automatique ‚Ä¢ Export / Import ‚Ä¢ Drag & Drop ‚Ä¢ **Centre $\to$ Branche $\to$ Comp√©tence $\to$ Sous-comp√©tence**</p>
        </div>

        <div class="layout">
            <div class="panel">
                <h2>Configuration</h2>

                <div>
                    <strong>Centre (D√©pla√ßable)</strong>
                    <div class="input-group">
                        <input type="text" id="centerInput" placeholder="Ex: Mes comp√©tences..." maxlength="60" />
                        <button id="addCenterBtn">Ajouter</button>
                    </div>
                    <div id="centerDisplay" class="item-list"><div style="color:#999;font-style:italic">Aucun centre d√©fini</div></div>
                </div>

                <hr style="margin:12px 0">

                <div>
                    <strong>Branches</strong>
                    <div class="input-group">
                        <input type="text" id="branchInput" placeholder="Ex: Techniques, Relationnelles" maxlength="30" />
                        <input type="color" id="branchColor" value="#fbbf24" title="Couleur de la branche" />
                        <button id="addBranchBtn">+ Branche</button>
                    </div>
                    <div id="branchList" class="item-list"><div style="color:#999;font-style:italic">Aucune branche</div></div>
                </div>

                <hr style="margin:12px 0">

                <div>
                    <strong>Comp√©tences</strong>
                    <div class="input-group" style="flex-wrap: wrap;">
                        <input type="text" id="skillInput" placeholder="Ex: Excel, Communication..." maxlength="40" style="flex: 1 1 100%;" />
                        <input type="color" id="skillColor" value="#10b981" title="Couleur de la comp√©tence" />
                        <select id="skillBranchSelect"></select>
                        <select id="skillLevelSelect" title="Niveau">
                            <option value="1">D√©butant</option>
                            <option value="2" selected>Interm√©diaire</option>
                            <option value="3">Avanc√©</option>
                        </select>
                        <button id="addSkillBtn">+ Comp√©tence</button>
                    </div>
                    <div id="skillList" class="item-list"><div style="color:#999;font-style:italic">Aucune comp√©tence</div></div>
                </div>

                <hr style="margin:12px 0">

                <div>
                    <strong>Sous-comp√©tences</strong>
                    <div class="input-group" style="flex-wrap: wrap;">
                        <input type="text" id="subskillInput" placeholder="Ex: Macro, Pivot..." maxlength="30" style="flex: 1 1 100%;" />
                        <select id="subskillBranchSelect"></select>
                        <select id="subskillSkillSelect"></select>
                        <select id="subskillLevelSelect" title="Niveau">
                            <option value="1">D√©butant</option>
                            <option value="2" selected>Interm√©diaire</option>
                            <option value="3">Avanc√©</option>
                        </select>
                        <button id="addSubskillBtn">+ Sous-comp√©tence</button>
                    </div>
                    <div id="subskillList" class="item-list"><div style="color:#999;font-style:italic">Aucune sous-comp√©tence</div></div>
                </div>
                <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap">
                    <button id="loadExample" class="btn-secondary">Charger un exemple</button>
                    <button id="gardenMode" class="btn-secondary">Mode Jardin (Hard/Soft)</button>
                    <button id="clearStorage" class="btn-secondary">Effacer sauvegarde</button>
                    
                    <div class="dropdown">
                        <button id="drawBtn">üéØ Redessiner / Mise √† jour</button>
                        <div class="dropdown-content">
                            <button onclick="generateMindmap()">üîÑ Mise √† jour des liens</button>
                            <button onclick="centerNodes()">üè† Recentrer la carte (positions des n≈ìuds)</button>
                        </div>
                    </div>
                </div>

                <div id="messageBox" class="message"></div>
                <div class="hint">Astuce: clic-droit ou Ctrl+drag pour pan; roulette pour zoom; drag gauche pour d√©placer un n≈ìud (y compris le Centre). Cliquez sur **Redessiner** apr√®s avoir d√©plac√© les n≈ìuds.</div>
            </div>

            <div class="panel">
                <h2>Visualisation & Export</h2>
                <div id="canvas-container">
                    <canvas id="mindmapCanvas" width="1200" height="700"></canvas>
                    
                    <div id="canvas-controls">
                        <button class="control-btn" onclick="zoomIn()" title="Zoomer">+</button>
                        <button class="control-btn" onclick="zoomOut()" title="D√©zoomer">‚àí</button>
                        <button class="control-btn" onclick="resetPanZoom()" title="R√©initialiser Pan/Zoom">‚åÇ</button>
                    </div>
                    </div>

                <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap">
                    <button id="downloadPng">üì• T√©l√©charger PNG</button>
                    <button id="exportJson" class="btn-secondary">‚¨áÔ∏è Exporter JSON</button>
                    <label style="display:inline-flex;align-items:center;gap:8px;cursor:pointer" class="btn-secondary">‚¨ÜÔ∏è Importer
                        <input id="importFile" type="file" accept="application/json" style="display:none" />
                    </label>
                    <button id="resetAll" class="btn-danger">üîÑ R√©initialiser</button>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-dot" style="background:#667eea"></div><span>Centre</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background:#fbbf24"></div><span>Branches</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background:#10b981"></div><span>Comp√©tences</span></div>
                    <div class="legend-item" style="margin-left:12px"><span>Niveaux:</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background:var(--level1-color, #9CA3AF)"></div><span>D√©butant</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background:var(--level2-color, #F59E0B)"></div><span>Interm√©diaire</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background:var(--level3-color, #10B981)"></div><span>Avanc√©</span></div>
                </div>
            </div>
        </div>
    </div>

<script>
// Single storage key
const STORAGE_KEY = 'mindmap_v2_data_standalone';

// ====================================================================
// >>> D√âBUT DES COULEURS DES NIVEAUX (√Ä PERSONNALISER) <<<
// Modifiez ces codes hexad√©cimaux pour changer les couleurs des pastilles
const LEVEL_COLORS = {
    1: '#9CA3AF', // NIVEAU 1 : Gris pour D√©butant.
    2: '#F59E0B', // NIVEAU 2 : Orange pour Interm√©diaire.
    3: '#10B981'  // NIVEAU 3 : Vert pour Avanc√©.
};
// >>> FIN DES COULEURS DES NIVEAUX (√Ä PERSONNALISER) <<<
// ====================================================================

// App data
let data = { center: null, branches: [], skills: {}, positions: {} };

// Canvas handles
let canvas = null;
let ctx = null;
// view transform (pan/zoom)
let view = { x: 0, y: 0, scale: 1 };
// currently computed nodes (with id)
let currentNodes = [];
// dragging state
let dragState = { dragging:false, nodeId:null, startX:0, startY:0, origX:0, origY:0 };
// panning state
let panState = { panning:false, startX:0, startY:0, origX:0, origY:0 };

function ensureCanvas(){ if(!canvas){ canvas = document.getElementById('mindmapCanvas'); if(canvas) ctx = canvas.getContext('2d'); } }

// Utilities
function showMessage(text, type='info'){ const box=document.getElementById('messageBox'); const bg = type==='success'? '#d4edda' : type==='error'? '#fff3cd' : '#e3f2fd'; box.innerHTML = `<div style="padding:8px;border-radius:8px;background:${bg}">${text}</div>`; setTimeout(()=>{ if(box.innerHTML.includes(text)) box.innerHTML=''; },3000); }
function truncate(s,n){ s=String(s||''); return s.length>n? s.slice(0,n-1)+'‚Ä¶': s; }
function hexToRgba(hex,alpha){ if(!hex) return `rgba(16,185,129,${alpha})`; const h=hex.replace('#',''); const bigint=parseInt(h,16); const r=(bigint>>16)&255; const g=(bigint>>8)&255; const b=bigint&255; return `rgba(${r},${g},${b},${alpha})`; }
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function escapeJs(s){ return String(s).replace(/'/g,"\\'").replace(/\"/g,'\\"'); }
function levelColor(n){ return LEVEL_COLORS[n] || LEVEL_COLORS[1]; }
function levelLabel(n){ return n===1? 'D√©butant' : n===3? 'Avanc√©' : 'Interm√©diaire'; }

// Met √† jour la l√©gende avec les couleurs personnalis√©es
function updateLegendColors() {
    document.documentElement.style.setProperty('--level1-color', LEVEL_COLORS[1]);
    document.documentElement.style.setProperty('--level2-color', LEVEL_COLORS[2]);
    document.documentElement.style.setProperty('--level3-color', LEVEL_COLORS[3]);
}


// --- Helper drawing functions that must be defined early ---
function clearCanvasLocal(){ ensureCanvas(); if(!ctx) return; try{ ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#f8f9fa'; ctx.fillRect(0,0,canvas.width,canvas.height); }catch(e){ console.warn('clearCanvasLocal failed',e); } }

function downloadImage(){ ensureCanvas(); if(!canvas){ showMessage('Aucune carte √† t√©l√©charger','error'); return; } try{ const url = canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=`carte_competences_${Date.now()}.png`; a.click(); URL.revokeObjectURL(url); showMessage('Image t√©l√©charg√©e','success'); }catch(e){ console.error('downloadImage failed',e); showMessage('Erreur t√©l√©chargement','error'); } }


// Persistence
function saveData(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }catch(e){ console.warn('save failed',e); } }
function loadData(){ const raw = localStorage.getItem(STORAGE_KEY); if(raw){ try{ data = JSON.parse(raw); }catch(e){ console.warn('parse fail',e); data={center:null,branches:[],skills:{},positions:{}} } } data.branches = data.branches || []; data.skills = data.skills || {}; data.positions = data.positions || {}; updateAllUI(); }

// UI updates
function updateCenterDisplay(){ const d=document.getElementById('centerDisplay'); if(data.center){ d.innerHTML = `<div class="item-chip"><strong>üéØ ${escapeHtml(data.center)}</strong><button onclick="removeCenter()">‚úï</button></div>` } else d.innerHTML = '<div style="color:#999;font-style:italic">Aucun centre d√©fini</div>'; }
function updateBranchList(){ const list=document.getElementById('branchList'); if(data.branches.length===0){ list.innerHTML = '<div style="color:#999;font-style:italic">Aucune branche</div>'; return; } list.innerHTML = data.branches.map((b,idx)=>`<div class="item-chip" style="border-left:6px solid ${b.color};"><span>${escapeHtml(b.name)}</span><div style="display:flex;gap:6px"><button onclick="removeBranch(${idx})">‚úï</button></div></div>`).join(''); }

function updateSkillBranchSelect(){ 
    const selSkillBranch=document.getElementById('skillBranchSelect'); 
    const selSubskillBranch=document.getElementById('subskillBranchSelect');
    [selSkillBranch, selSubskillBranch].forEach(sel => {
        sel.innerHTML=''; 
        data.branches.forEach(b=>{ 
            const opt=document.createElement('option'); 
            opt.value=b.name; opt.textContent=b.name; 
            sel.appendChild(opt); 
        }); 
        if(data.branches.length===0) sel.innerHTML = '<option value="">-- Aucune branche --</option>';
    });
    // Update skill selector for subskills initially
    updateSubskillSkillSelect();
}

// NOUVELLE FONCTION : Met √† jour le s√©lecteur de comp√©tences pour les sous-comp√©tences
function updateSubskillSkillSelect(){
    const branchName = document.getElementById('subskillBranchSelect').value;
    const sel = document.getElementById('subskillSkillSelect');
    sel.innerHTML='';
    const skills = data.skills[branchName] || [];

    if(skills.length===0){
        sel.innerHTML = '<option value="">-- Aucune comp√©tence --</option>';
        return;
    }

    skills.forEach(s => {
        const opt=document.createElement('option');
        opt.value=s.name; 
        opt.textContent=s.name; 
        sel.appendChild(opt);
    });
}

// Affichage de la liste des comp√©tences
function updateSkillList(){
    const list=document.getElementById('skillList');
    const all=[];
    data.branches.forEach(b=>{
        (data.skills[b.name]||[]).forEach(s=> all.push({ branch:b.name, branchColor:b.color, name:s.name, level:s.level, color:s.color || b.color, subskillsCount: (s.subskills||[]).length }));
    });
    
    if(all.length===0){
        list.innerHTML = '<div style="color:#999;font-style:italic">Aucune comp√©tence</div>';
        return;
    }

    list.innerHTML = all.map((it,idx)=>`
        <div class="item-chip" style="border-left:6px solid ${it.branchColor};">
            <div style="display:flex;align-items:center;gap:8px">
                <span style="width:12px;height:12px;border-radius:50%;background:${levelColor(it.level)};display:inline-block" title="Niveau: ${levelLabel(it.level)}"></span>
                <strong>${escapeHtml(it.name)}</strong>
                <div style="font-size:0.85em;color:#666;margin-left:8px">${escapeHtml(it.branch)} ‚Ä¢ ${levelLabel(it.level)} (${it.subskillsCount} s-comp.)</div>
            </div>
            <div>
                <button onclick="removeSkill('${escapeJs(it.branch)}','${escapeJs(it.name)}')">‚úï</button>
            </div>
        </div>
    `).join('');
}

// NOUVELLE FONCTION : Affichage de la liste des sous-comp√©tences
function updateSubskillList(){
    const list=document.getElementById('subskillList');
    const all=[];
    data.branches.forEach(b=>{
        (data.skills[b.name]||[]).forEach(s => {
            (s.subskills||[]).forEach(ss => {
                all.push({ 
                    branch:b.name, 
                    skill: s.name, 
                    skillColor: s.color || b.color, 
                    name:ss.name, 
                    level:ss.level 
                });
            });
        });
    });

    if(all.length===0){
        list.innerHTML = '<div style="color:#999;font-style:italic">Aucune sous-comp√©tence</div>';
        return;
    }

    list.innerHTML = all.map((it,idx)=>`
        <div class="item-chip" style="border-left:6px solid ${it.skillColor};">
            <div style="display:flex;align-items:center;gap:8px">
                <span style="width:12px;height:12px;border-radius:50%;background:${levelColor(it.level)};display:inline-block" title="Niveau: ${levelLabel(it.level)}"></span>
                <strong>${escapeHtml(it.name)}</strong>
                <div style="font-size:0.85em;color:#666;margin-left:8px">${escapeHtml(it.branch)} / ${escapeHtml(it.skill)} ‚Ä¢ ${levelLabel(it.level)}</div>
            </div>
            <div>
                <button onclick="removeSubskill('${escapeJs(it.branch)}','${escapeJs(it.skill)}','${escapeJs(it.name)}')">‚úï</button>
            </div>
        </div>
    `).join('');
}


// CRUD
function addCenter(){ 
    ensureCanvas();
    const v=document.getElementById('centerInput').value.trim(); 
    if(!v){ showMessage('Veuillez entrer un titre','error'); return; } 
    
    data.center=v; 
    
    // Initialise la position du centre si elle n'existe pas
    if(!data.positions['center']){
        data.positions['center'] = { x: canvas.width/2, y: canvas.height/2 };
    }
    
    document.getElementById('centerInput').value=''; 
    saveData(); 
    updateCenterDisplay(); 
    showMessage('Centre d√©fini (maintenant d√©pla√ßable)','success'); 
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

function removeCenter(){ 
    data.center=null; 
    delete data.positions['center']; // Supprime aussi la position
    saveData(); 
    updateCenterDisplay(); 
    showMessage('Centre supprim√©','success'); 
}

function addBranch(){ const name=document.getElementById('branchInput').value.trim(); const color=document.getElementById('branchColor').value || '#fbbf24'; if(!name){ showMessage('Veuillez entrer un titre de branche','error'); return; } if(data.branches.length>=12){ showMessage('Maximum recommand√©: 12 branches','error'); return; } if(data.branches.find(b=>b.name===name)){ showMessage('Branche d√©j√† existante','error'); return; } const branch={name,color}; data.branches.push(branch); data.skills[name]=data.skills[name]||[]; document.getElementById('branchInput').value=''; saveData(); updateBranchList(); updateSkillBranchSelect(); showMessage('Branche ajout√©e','success'); try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } }
function removeBranch(idx){ 
    const name=data.branches[idx].name; 
    delete data.skills[name]; 
    data.branches.splice(idx,1); 
    // Suppression des positions des noeuds enfants (branches, skills, subskills)
    Object.keys(data.positions).filter(id => id.startsWith(`branch:${name}`) || id.startsWith(`skill:${name}`)).forEach(id => delete data.positions[id]);
    saveData(); 
    updateBranchList(); 
    updateSkillList(); 
    updateSubskillList();
    updateSkillBranchSelect(); 
    showMessage('Branche supprim√©e','success'); 
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

function addSkill(){ 
    const val=document.getElementById('skillInput').value.trim(); 
    const branch=document.getElementById('skillBranchSelect').value; 
    const level=parseInt(document.getElementById('skillLevelSelect').value,10)||2; 
    const color=document.getElementById('skillColor')?document.getElementById('skillColor').value:'#10b981'; 
    if(!val){ showMessage('Veuillez entrer une comp√©tence','error'); return; } 
    if(!branch){ showMessage('S√©lectionnez une branche','error'); return; } 
    
    const arr=data.skills[branch]=data.skills[branch]||[]; 
    if(arr.find(s=>s.name===val)){ showMessage('Comp√©tence d√©j√† existante dans cette branche','error'); return; } 
    
    // Ajout du tableau subskills (obligatoire pour le 4√®me niveau)
    arr.push({name:val,level,color, subskills:[]}); 
    
    document.getElementById('skillInput').value=''; 
    saveData(); 
    updateSkillList(); 
    updateSubskillSkillSelect(); // Met √† jour le s√©lecteur pour les sous-comp√©tences
    showMessage('Comp√©tence ajout√©e','success'); 
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

function removeSkill(branch,skill){ 
    data.skills[branch]=(data.skills[branch]||[]).filter(s=>{
        if(s.name===skill){
            // Suppression des positions des sous-comp√©tences
            Object.keys(data.positions).filter(id => id.startsWith(`subskill:${branch}:${skill}`)).forEach(id => delete data.positions[id]);
            return false;
        }
        return true;
    });
    
    // Suppression de la position de la comp√©tence elle-m√™me
    delete data.positions[`skill:${branch}:${skill}`];

    saveData(); 
    updateSkillList(); 
    updateSubskillList();
    updateSubskillSkillSelect();
    showMessage('Comp√©tence supprim√©e','success');
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

// NOUVELLE FONCTION : Ajout de sous-comp√©tence
function addSubskill(){
    const val=document.getElementById('subskillInput').value.trim();
    const branch=document.getElementById('subskillBranchSelect').value;
    const skillName=document.getElementById('subskillSkillSelect').value;
    const level=parseInt(document.getElementById('subskillLevelSelect').value,10)||2;

    if(!val){ showMessage('Veuillez entrer une sous-comp√©tence','error'); return; }
    if(!branch || !skillName){ showMessage('S√©lectionnez une branche et une comp√©tence','error'); return; }

    const skills = data.skills[branch] || [];
    const parentSkill = skills.find(s => s.name === skillName);

    if(!parentSkill){ showMessage('Comp√©tence parente non trouv√©e','error'); return; }
    
    parentSkill.subskills = parentSkill.subskills || [];
    if(parentSkill.subskills.find(ss => ss.name === val)){
        showMessage('Sous-comp√©tence d√©j√† existante dans cette comp√©tence','error'); 
        return;
    }

    parentSkill.subskills.push({name:val, level}); // Pas de couleur sp√©cifique pour subskill pour le moment
    
    document.getElementById('subskillInput').value=''; 
    saveData(); 
    updateSkillList(); // Mise √† jour du compteur de sous-comp√©tences
    updateSubskillList();
    showMessage('Sous-comp√©tence ajout√©e','success'); 
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

// NOUVELLE FONCTION : Suppression de sous-comp√©tence
function removeSubskill(branch, skill, subskill){
    const skills = data.skills[branch] || [];
    const parentSkill = skills.find(s => s.name === skill);

    if(parentSkill){
        parentSkill.subskills = (parentSkill.subskills || []).filter(ss => ss.name !== subskill);
        // Suppression de la position de la sous-comp√©tence
        delete data.positions[`subskill:${branch}:${skill}:${subskill}`];
    }

    saveData();
    updateSkillList(); // Mise √† jour du compteur
    updateSubskillList();
    showMessage('Sous-comp√©tence supprim√©e','success');
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}


// Export / Import
function exportJSON(){ const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='carte_competences.json'; a.click(); URL.revokeObjectURL(url); showMessage('Export JSON g√©n√©r√©','success'); }
function importJSON(ev){ const f=ev.target.files&&ev.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const obj=JSON.parse(r.result); if(!obj) throw 'Invalid'; 
    data=obj; 
    // Nettoyage de structure pour compatibilit√© avec le 4√®me niveau
    data.branches.forEach(b => {
        (data.skills[b.name]||[]).forEach(s => {
            s.subskills = s.subskills || []; // Assure la pr√©sence du tableau
        });
    });
    saveData(); 
    updateAllUI(); 
    showMessage('Import r√©ussi','success'); 
    try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } }catch(e){ showMessage('Fichier invalide','error'); } }; r.readAsText(f); ev.target.value=''; }

// Centrage des noeuds (Supprime les positions enregistr√©es)
function centerNodes(){
    if(!data.center){
        showMessage("Le centre n'est pas d√©fini. Ajoutez-en un d'abord.", 'error');
        return;
    }
    
    if(confirm('Ceci va supprimer toutes les positions enregistr√©es des branches et des comp√©tences/sous-comp√©tences pour recentrer la carte. Continuer ?')){
        data.positions = {};
        // Initialise la position du centre au milieu du canevas
        ensureCanvas();
        data.positions['center'] = { x: canvas.width/2, y: canvas.height/2 };
        saveData();
        resetPanZoom(); // R√©initialise aussi le pan et zoom de la vue
        showMessage('Carte recentr√©e et positions r√©initialis√©es.','success');
    }
}

// NOUVELLES FONCTIONS DE ZOOM
function adjustZoom(delta) {
    ensureCanvas();
    // Zoom autour du centre de la vue (viewport)
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const newScale = Math.max(0.3, Math.min(3, view.scale * delta));
    
    // Applique la transformation de zoom autour du centre
    view.x = cx - (cx - view.x) * (newScale / view.scale);
    view.y = cy - (cy - view.y) * (newScale / view.scale);
    view.scale = newScale;
    generateMindmap();
}

function zoomIn(){
    adjustZoom(1.25); // Facteur de zoom
}

function zoomOut(){
    adjustZoom(0.8); // Facteur de d√©zoom
}

function resetPanZoom(){
    view.x = 0; 
    view.y = 0; 
    view.scale = 1; 
    view._initialized = false;
    view._resetScale = true; // Force le recalcul de l'√©chelle de base
    generateMindmap();
    showMessage('Vue r√©initialis√©e (Pan et Zoom)','success');
}
// FIN NOUVELLES FONCTIONS DE ZOOM


// Garden/example/reset
function loadGardenMode(){ 
    data={ 
        center:'Mes Comp√©tences', 
        branches:[ 
            {name:'Hard skills',color:'#3b82f6'},
            {name:'Soft skills',color:'#f59e0b'} 
        ], 
        skills:{ 
            'Hard skills':[
                {name:'Excel',level:3,color:'#3b82f6', subskills:[{name:'VBA',level:2},{name:'TCD',level:3}]},
                {name:'Python',level:2,color:'#60a5fa', subskills:[]}
            ], 
            'Soft skills':[
                {name:'Communication',level:3,color:'#f59e0b', subskills:[]},
                {name:'Esprit d\'√©quipe',level:2,color:'#f9a8d4', subskills:[{name:'Gestion conflit',level:2}]}
            ] 
        }, 
        positions: data.positions||{} 
    }; 
    saveData(); updateAllUI(); showMessage('Mode Jardin charg√© ‚Äî triez vos comp√©tences en Hard / Soft','success'); try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}

function loadExample(){ 
    data={ 
        center:'Mes Comp√©tences', 
        branches:[ 
            {name:'Techniques',color:'#3b82f6'},
            {name:'Relationnelles',color:'#f59e0b'},
            {name:'Gestion',color:'#10b981'} 
        ], 
        skills:{ 
            'Techniques':[ 
                {name:'Excel',level:3,color:'#3b82f6', subskills:[{name:'VBA',level:2},{name:'TCD',level:3}]},
                {name:'JS',level:2,color:'#60a5fa', subskills:[{name:'Framework',level:2}]},
            ], 
            'Relationnelles':[ 
                {name:'Communication',level:3,color:'#f59e0b', subskills:[{name:'Ecoute',level:3}]},
            ], 
            'Gestion':[ 
                {name:'Planification',level:2,color:'#10b981', subskills:[]},
            ] 
        }, 
        positions: {} 
    }; 
    saveData(); updateAllUI(); showMessage('Exemple charg√©','success'); try{ generateMindmap(); }catch(e){ console.error(e); showMessage('Erreur lors du dessin','error'); } 
}
function resetAll(){ 
    if(!confirm('R√©initialiser toutes les donn√©es ?')) return; 
    data={center:null,branches:[],skills:{},positions:{}}; 
    saveData(); 
    updateAllUI(); 
    clearCanvasLocal();
    showMessage('R√©initialis√©','success'); 
}

function updateAllUI(){ 
    updateCenterDisplay(); 
    updateBranchList(); 
    updateSkillList(); 
    updateSubskillList(); // NOUVEAU
    updateSkillBranchSelect(); 
    updateLegendColors(); 
}

// Node id helper
function nodeIdFor(n){ 
    if(n.type==='center') return 'center'; 
    if(n.type==='branch') return `branch:${n.text}`; 
    if(n.type==='skill') return `skill:${n.parentName}:${n.text}`; 
    if(n.type==='subskill') return `subskill:${n.grandParentName}:${n.parentName}:${n.text}`; // NOUVEAU
    return n.type+':'+n.text; 
}

// Dynamic radius based on text width
function computeRadius(text, type, ctx){
    // R√©duction du radius min pour la sous-comp√©tence
    if(!ctx) return type==='center' ? 48 : type==='branch' ? 28 : type==='skill' ? 14 : 10; 
    let fontSize, padding, rMin;
    if(type==='center'){ fontSize = 16; padding = 16; rMin = 48; }
    else if(type==='branch'){ fontSize = 12; padding = 12; rMin = 28; }
    else if(type==='skill'){ fontSize = 11; padding = 10; rMin = 14; }
    else if(type==='subskill'){ fontSize = 10; padding = 8; rMin = 10; } // NOUVEAU
    else return 14;

    ctx.font = `bold ${fontSize}px Arial`;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const requiredRadius = Math.max(textWidth / 2 + padding, rMin);
    return requiredRadius;
}

// Main drawing: computes layout but respects saved positions in data.positions
function generateMindmap(){ try{ ensureCanvas(); if(!ctx){ showMessage('Impossible d\'obtenir le contexte du canvas','error'); return; } 
 // basic checks
 if(!data.center){ showMessage('D√©finissez d\'abord le centre','error'); return; } // if(data.branches.length===0){ showMessage('Ajoutez au moins une branche','error'); return; }
 
 // resize canvas to container size
 const container = document.getElementById('canvas-container'); const rect = container.getBoundingClientRect(); // set canvas pixel size
 const dpr = window.devicePixelRatio || 1; canvas.width = Math.max(800, Math.min(2000, Math.floor(rect.width * dpr)));
 canvas.height = Math.max(500, Math.floor((rect.height||700) * dpr));
 
 // clear current nodes
 currentNodes = [];
 
 // core layout in world coordinates
 const cx_default = canvas.width/2; 
 const cy_default = canvas.height/2;

 // 1. Initial/Default layout calculation (used for reference and initial positioning)
 const nodes = [];
 const centerText = truncate(data.center, 24);
 const centerR = computeRadius(centerText, 'center', ctx);
 
 // NOUVEAU: R√©cup√®re la position enregistr√©e ou utilise la position par d√©faut du canevas
 const centerPos = data.positions['center'] || { x: cx_default, y: cy_default }; 
 const centerNode = {type:'center', x:centerPos.x, y:centerPos.y, r:centerR, text:centerText, color:'#667eea'};
 
 // Si c'est la premi√®re fois, enregistre la position par d√©faut
 if(!data.positions['center']){
     data.positions['center'] = { x: centerNode.x, y: centerNode.y };
     saveData();
 }
 
 nodes.push(centerNode);

 const branchNodes = []; // Store branches to link skills
 const skillNodes = {}; // Store skills to link subskills
 const branchCount = data.branches.length; 
 const angleStep = (Math.PI*2)/branchCount;
 const distance = 220 + branchCount * 10; // spread branches a bit more

 data.branches.forEach((b,i)=>{
     const angle = angleStep * i - Math.PI/2;
     
     // Position initiale par rapport au centre du canevas (pour le calcul de la position par d√©faut)
     const bx0 = cx_default + Math.cos(angle)*distance; 
     const by0 = cy_default + Math.sin(angle)*distance;
     
     const branchText = truncate(b.name, 12);
     const branchR = computeRadius(branchText, 'branch', ctx);
     
     // R√©cup√®re la position enregistr√©e ou utilise la position par d√©faut (bx0, by0)
     const bid = `branch:${b.name}`;
     const branchPos = data.positions[bid] || { x: bx0, y: by0 };
     
     const branchNode = {type:'branch', x:branchPos.x, y:branchPos.y, r:branchR, text:branchText, color:b.color, fullName: b.name};
     
     branchNodes.push(branchNode);
     nodes.push(branchNode);
     
     const skills = (data.skills[b.name]||[]);
     const spread = Math.min(Math.PI/2, Math.PI/3 + skills.length*0.05);
     const start = angle - spread/2; const step = skills.length>0? spread/(skills.length+1):0;
     
     skills.forEach((s,idx)=>{
         const a = start + step*(idx+1);
         
         // Position initiale/par d√©faut relative √† la position par d√©faut de la branche (bx0, by0)
         const sx0 = branchPos.x + Math.cos(a)*140; 
         const sy0 = branchPos.y + Math.sin(a)*140;
         
         const skillText = truncate(s.name, 12);
         const radius = computeRadius(skillText, 'skill', ctx);
         
         const skid = `skill:${b.name}:${s.name}`;
         const skillPos = data.positions[skid] || { x: sx0, y: sy0 };
         
         const skillNode = {
             type:'skill', x:skillPos.x, y:skillPos.y, r:radius, text:skillText, 
             color:s.color||b.color, parentName:b.name, level:s.level, fullName: s.name
         };
         
         skillNodes[skid] = skillNode; // Stockage pour les sous-comp√©tences
         nodes.push(skillNode);

         // NOUVEAU : CALCUL DES SOUS-COMP√âTENCES
         const subskills = (s.subskills || []);
         const subSpread = Math.min(Math.PI/2, Math.PI/3 + subskills.length*0.05);
         const subStart = a - subSpread/2; const subStep = subskills.length>0? subSpread/(subskills.length+1):0;
         const subDistance = 80;

         subskills.forEach((ss, subIdx) => {
             const subA = subStart + subStep*(subIdx+1);
             const ssx0 = skillPos.x + Math.cos(subA)*subDistance;
             const ssy0 = skillPos.y + Math.sin(subA)*subDistance;

             const subskillText = truncate(ss.name, 10);
             const subRadius = computeRadius(subskillText, 'subskill', ctx);

             const ssid = `subskill:${b.name}:${s.name}:${ss.name}`;
             const subskillPos = data.positions[ssid] || { x: ssx0, y: ssy0 };

             const subskillNode = {
                type:'subskill', x:subskillPos.x, y:subskillPos.y, r:subRadius, text:subskillText,
                color:s.color||b.color, // H√©rite de la couleur de la comp√©tence
                grandParentName: b.name,
                parentName: s.name,
                level: ss.level
             };
             nodes.push(subskillNode);
         });
         // FIN NOUVEAU
     });
 });

 // 2. Final node list with updated branch positions (to correctly calculate skill links)
 currentNodes = nodes.map(n=>{ 
     const id = nodeIdFor(n);
     if(n.type === 'skill'){
         const parentBranch = branchNodes.find(b=>b.fullName===n.parentName); // Utiliser fullName
         // Fixe la comp√©tence √† la position actuelle (sauvegard√©e ou par d√©faut) de la branche parente
         n.parent = { x: parentBranch.x, y: parentBranch.y };
     } else if (n.type === 'branch'){
         // Fixe la branche √† la position actuelle du centre
         n.parent = { x: centerNode.x, y: centerNode.y };
     } else if (n.type === 'subskill'){ // NOUVEAU : PARENT DE LA SOUS-COMP√âTENCE
        const parentSkill = skillNodes[`skill:${n.grandParentName}:${n.parentName}`];
        if (parentSkill) {
            n.parent = { x: parentSkill.x, y: parentSkill.y };
        } else {
            // Failsafe: link to center or branch
            n.parent = { x: centerNode.x, y: centerNode.y };
        }
     }
     return {...n, id}; 
 });

 // 3. Compute bounding box and view transformation
 let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; 
 currentNodes.forEach(n=>{ minX=Math.min(minX,n.x-n.r-10); minY=Math.min(minY,n.y-n.r-10); maxX=Math.max(maxX,n.x+n.r+10); maxY=Math.max(maxY,n.y+n.r+10); });
 
 const contentW = maxX-minX, contentH = maxY-minY; const padding = 40; const availableW = canvas.width - padding*2, availableH = canvas.height - padding*2; 
 const baseScale = Math.min(1, availableW / contentW, availableH / contentH);
 
 // initialize view.scale on first draw
 if(!view.scale || view._resetScale) { view.scale = baseScale; view._resetScale = false; }
 
 // center content in view coordinates if not initialized
 const offsetX = (canvas.width - contentW*view.scale)/2 - minX*view.scale;
 const offsetY = (canvas.height - contentH*view.scale)/2 - minY*view.scale;
 if(!view._initialized){ view.x = offsetX; view.y = offsetY; view._initialized = true; }

 // 4. Draw using view transform
 clearCanvasLocal(); ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);

 // draw center
 // Le centre est le point de d√©part de toutes les lignes des branches
 
 // draw branches
 currentNodes.filter(n=>n.type==='branch').forEach(bn=>{ 
     ctx.strokeStyle = bn.color || '#fbbf24'; ctx.lineWidth=4; 
     ctx.beginPath(); ctx.moveTo(centerNode.x,centerNode.y); ctx.lineTo(bn.x,bn.y); ctx.stroke(); // Ligne Centre -> Branche
     ctx.fillStyle = bn.color || '#fbbf24'; ctx.beginPath(); ctx.arc(bn.x,bn.y,bn.r,0,Math.PI*2); ctx.fill(); 
     ctx.fillStyle='#fff'; ctx.font='bold 12px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(bn.text, bn.x, bn.y); 
 });
 
 // draw skills
 currentNodes.filter(n=>n.type==='skill').forEach(sn=>{ 
     ctx.strokeStyle = hexToRgba(sn.color||'#10b981',0.35); ctx.lineWidth=2; 
     ctx.beginPath(); ctx.moveTo(sn.parent.x, sn.parent.y); ctx.lineTo(sn.x, sn.y); ctx.stroke(); // Ligne Branche -> Comp√©tence
     ctx.fillStyle = sn.color||'#10b981'; ctx.beginPath(); ctx.arc(sn.x,sn.y,sn.r,0,Math.PI*2); ctx.fill(); 
     
     // Pastille de niveau sur la carte
     ctx.fillStyle = levelColor(sn.level);
     ctx.beginPath();
     ctx.arc(sn.x + sn.r - 5, sn.y - sn.r + 5, 4, 0, Math.PI*2); // Petit cercle en haut √† droite
     ctx.fill();
     
     ctx.fillStyle='#fff'; ctx.font='bold 11px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; 
     ctx.fillText(sn.text, sn.x, sn.y); 
 });

 // NOUVEAU : draw subskills
 currentNodes.filter(n=>n.type==='subskill').forEach(ssn=>{ 
     const parentSkillNode = currentNodes.find(n => n.id === `skill:${ssn.grandParentName}:${ssn.parentName}`);
     const parentX = parentSkillNode ? parentSkillNode.x : ssn.parent.x;
     const parentY = parentSkillNode ? parentSkillNode.y : ssn.parent.y;
     
     ctx.strokeStyle = hexToRgba(ssn.color||'#10b981',0.15); ctx.lineWidth=1; 
     ctx.beginPath(); ctx.moveTo(parentX, parentY); ctx.lineTo(ssn.x, ssn.y); ctx.stroke(); // Ligne Comp√©tence -> Sous-Comp√©tence
     ctx.fillStyle = ssn.color||'#10b981'; 
     ctx.globalAlpha = 0.8; // Transparence pour le 4√®me niveau
     ctx.beginPath(); ctx.arc(ssn.x,ssn.y,ssn.r,0,Math.PI*2); ctx.fill(); 
     ctx.globalAlpha = 1.0;
     
     // Pastille de niveau sur la carte
     ctx.fillStyle = levelColor(ssn.level);
     ctx.beginPath();
     ctx.arc(ssn.x + ssn.r - 3, ssn.y - ssn.r + 3, 3, 0, Math.PI*2); // Petit cercle en haut √† droite
     ctx.fill();
     
     ctx.fillStyle='#fff'; ctx.font='bold 10px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; 
     ctx.fillText(ssn.text, ssn.x, ssn.y); 
 });
 
 // Redessine le centre en dernier pour qu'il soit au-dessus de tout
 currentNodes.filter(n=>n.type==='center').forEach(n=>{ 
     ctx.beginPath(); 
     ctx.fillStyle=n.color; 
     ctx.arc(n.x,n.y,n.r,0,Math.PI*2); 
     ctx.fill(); 
     ctx.fillStyle='#fff'; 
     ctx.font='bold 16px Arial'; 
     ctx.textAlign='center'; 
     ctx.textBaseline='middle'; 
     ctx.fillText(n.text, n.x, n.y); 
 });
 
 ctx.restore(); showMessage('Carte g√©n√©r√©e et liens resynchronis√©s.','success'); 
}catch(err){ console.error('generateMindmap error',err); showMessage('Erreur lors du dessin ‚Äî regarde la console (F12)','error'); } }

// Save position helper
function persistNodePosition(id, x, y){ 
    data.positions = data.positions || {}; 
    data.positions[id] = { x, y }; 
    saveData(); 
}

// Hit testing and dragging
function findNodeAtScreen(px,py){ const world = screenToWorld(px,py); for(let i=currentNodes.length-1;i>=0;i--){ const n=currentNodes[i]; const dx = world.x - n.x; const dy = world.y - n.y; if(Math.sqrt(dx*dx+dy*dy) <= n.r + 6) return n; } return null; }

// Pointer event handlers (Mise √† jour pour g√©rer le centre)
function onPointerDown(e){ ensureCanvas(); if(!canvas) return; 
    // Emp√™che le drag/pan si l'on clique sur un bouton de contr√¥le
    if (e.target.closest('#canvas-controls')) return; 

    const isLeft = e.button===0; 
    const isRight = e.button===2; 
    const shouldPan = isRight || (isLeft && e.ctrlKey); 
    
    if(shouldPan){ 
        panState.panning = true; 
        panState.startX = e.clientX; 
        panState.startY = e.clientY; 
        panState.origX = view.x; 
        panState.origY = view.y; 
        try{ canvas.setPointerCapture(e.pointerId);}catch(_){} 
        return; 
    } 
    
    const hit = findNodeAtScreen(e.clientX, e.clientY); 
    if(hit){ 
        dragState.dragging = true; 
        dragState.nodeId = hit.id; 
        dragState.startX = e.clientX; 
        dragState.startY = e.clientY; 
        dragState.origX = hit.x; 
        dragState.origY = hit.y; 
        try{ canvas.setPointerCapture(e.pointerId);}catch(_){} 
    } 
}

function onPointerMove(e){ ensureCanvas(); if(!canvas) return; 
    if(panState.panning){ 
        const dx = e.clientX - panState.startX; 
        const dy = e.clientY - panState.startY; 
        view.x = panState.origX + dx; 
        view.y = panState.origY + dy; 
        generateMindmap(); 
        return; 
    } 
    
    if(dragState.dragging && dragState.nodeId){ 
        const n = currentNodes.find(n=>n.id===dragState.nodeId); 
        if(!n) return; 
        const world = screenToWorld(e.clientX,e.clientY);
        
        // D√©place le n≈ìud
        n.x = world.x; 
        n.y = world.y; 

        // Gestion des liens parents/enfants pour l'affichage imm√©diat
        const centerNode = currentNodes.find(c => c.type === 'center');
        
        // Si on bouge le centre, on met √† jour toutes les branches parentes (pour l'affichage imm√©diat)
        if (n.type === 'center') {
            currentNodes.filter(b => b.type === 'branch').forEach(b => {
                b.parent = { x: n.x, y: n.y };
            });
        }

        // Si on bouge une branche, on met √† jour toutes les comp√©tences parentes (pour l'affichage imm√©diat)
        if (n.type === 'branch') {
            currentNodes.filter(s => s.type === 'skill' && s.parentName === n.fullName).forEach(s => {
                s.parent = { x: n.x, y: n.y };
            });
        }

        // Si on bouge une comp√©tence, on met √† jour toutes les sous-comp√©tences parentes (pour l'affichage imm√©diat)
        if (n.type === 'skill') {
            currentNodes.filter(ss => ss.type === 'subskill' && ss.parentName === n.fullName).forEach(ss => {
                ss.parent = { x: n.x, y: n.y };
            });
        }

        // Redraw optimis√© pour le drag (r√©p√©tition du code de dessin)
        clearCanvasLocal(); ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale); 
        
        // Dessin du centre
        currentNodes.filter(c => c.type === 'center').forEach(c => { 
            ctx.beginPath(); ctx.fillStyle=c.color; ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='#fff'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(c.text, c.x, c.y); 
        }); 
        
        // Dessin des branches et liens
        currentNodes.filter(b => b.type === 'branch').forEach(bn => { 
            ctx.strokeStyle = bn.color || '#fbbf24'; ctx.lineWidth=4; 
            ctx.beginPath(); ctx.moveTo(centerNode.x,centerNode.y); ctx.lineTo(bn.x,bn.y); ctx.stroke(); 
            ctx.fillStyle = bn.color || '#fbbf24'; ctx.beginPath(); ctx.arc(bn.x,bn.y,bn.r,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='#fff'; ctx.font='bold 12px Arial'; ctx.fillText(bn.text, bn.x, bn.y); 
        }); 
        
        // Dessin des comp√©tences et liens
        currentNodes.filter(s => s.type === 'skill').forEach(sn => { 
            const parentBranch = currentNodes.find(b => b.type === 'branch' && b.text === truncate(sn.parentName, 12));
            const parentX = parentBranch ? parentBranch.x : sn.parent.x;
            const parentY = parentBranch ? parentBranch.y : sn.parent.y;
            
            ctx.strokeStyle = hexToRgba(sn.color||'#10b981',0.35); ctx.lineWidth=2; 
            ctx.beginPath(); ctx.moveTo(parentX, parentY); ctx.lineTo(sn.x, sn.y); ctx.stroke(); 
            ctx.fillStyle = sn.color||'#10b981'; ctx.beginPath(); ctx.arc(sn.x,sn.y,sn.r,0,Math.PI*2); ctx.fill(); 
            
            // Pastille de niveau
            ctx.fillStyle = levelColor(sn.level);
            ctx.beginPath();
            ctx.arc(sn.x + sn.r - 5, sn.y - sn.r + 5, 4, 0, Math.PI*2); 
            ctx.fill();
            
            ctx.fillStyle='#fff'; ctx.font='bold 11px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(sn.text, sn.x, sn.y); 
        }); 

        // Dessin des sous-comp√©tences et liens (Nouveau)
        currentNodes.filter(ss => ss.type === 'subskill').forEach(ssn => {
            const parentSkillNode = currentNodes.find(n => n.id === `skill:${ssn.grandParentName}:${ssn.parentName}`);
            const parentX = parentSkillNode ? parentSkillNode.x : ssn.parent.x;
            const parentY = parentSkillNode ? parentSkillNode.y : ssn.parent.y;

            ctx.strokeStyle = hexToRgba(ssn.color||'#10b981',0.15); ctx.lineWidth=1; 
            ctx.globalAlpha = 0.8; 
            ctx.beginPath(); ctx.moveTo(parentX, parentY); ctx.lineTo(ssn.x, ssn.y); ctx.stroke(); 

            ctx.fillStyle = ssn.color||'#10b981'; 
            ctx.beginPath(); ctx.arc(ssn.x,ssn.y,ssn.r,0,Math.PI*2); ctx.fill(); 
            ctx.globalAlpha = 1.0;

            // Pastille de niveau
            ctx.fillStyle = levelColor(ssn.level);
            ctx.beginPath();
            ctx.arc(ssn.x + ssn.r - 3, ssn.y - ssn.r + 3, 3, 0, Math.PI*2); 
            ctx.fill();

            ctx.fillStyle='#fff'; ctx.font='bold 10px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(ssn.text, ssn.x, ssn.y); 
        });
        
        ctx.restore(); 
    } 
}

function onPointerUp(e){ ensureCanvas(); if(!canvas) return; 
    
    if(panState.panning){ 
        panState.panning=false; 
        try{ canvas.releasePointerCapture(e.pointerId);}catch(_){}; 
        generateMindmap(); 
        return; 
    } 
    
    if(dragState.dragging && dragState.nodeId){ 
        const n = currentNodes.find(n=>n.id===dragState.nodeId); 
        if(n){ 
            // Enregistre la nouvelle position du n≈ìud (centre, branche, comp√©tence ou sous-comp√©tence)
            persistNodePosition(n.id, n.x, n.y); 
        } 
        dragState.dragging=false; 
        dragState.nodeId=null; 
        try{ canvas.releasePointerCapture(e.pointerId);}catch(_){} 
        
        // Redraw complet pour s'assurer que tout est synchronis√©
        generateMindmap();
    } 
}

// Wheel for zoom
function onWheel(e){ ensureCanvas(); if(!canvas) return; e.preventDefault(); const rect = canvas.getBoundingClientRect(); const sx = e.clientX - rect.left; const sy = e.clientY - rect.top; const ratioX = canvas.width / rect.width; const ratioY = canvas.height / rect.height; const cx = sx * ratioX; const cy = sy * ratioY; const delta = e.deltaY > 0 ? 0.9 : 1.1; const newScale = Math.max(0.3, Math.min(3, view.scale * delta)); view.x = cx - (cx - view.x) * (newScale / view.scale); view.y = cy - (cy - view.y) * (newScale / view.scale); view.scale = newScale; generateMindmap(); }

// convert screen px to world coords
function screenToWorld(px,py){ ensureCanvas(); const rect = canvas.getBoundingClientRect(); const sx = (px - rect.left); const sy = (py - rect.top); const ratioX = canvas.width / rect.width; const ratioY = canvas.height / rect.height; const cx = sx * ratioX; const cy = sy * ratioY; const wx = (cx - view.x) / view.scale; const wy = (cy - view.y) / view.scale; return {x:wx, y:wy}; }

// init bindings
window.addEventListener('load', ()=>{
    document.getElementById('addCenterBtn').addEventListener('click', addCenter);
    document.getElementById('addBranchBtn').addEventListener('click', addBranch);
    document.getElementById('addSkillBtn').addEventListener('click', addSkill);
    document.getElementById('addSubskillBtn').addEventListener('click', addSubskill); // NOUVEAU
    
    // Mise √† jour de la liste des comp√©tences quand la branche change
    document.getElementById('subskillBranchSelect').addEventListener('change', updateSubskillSkillSelect); // NOUVEAU

    // Le bouton drawBtn est maintenant un dropdown, mais l'action par d√©faut reste generateMindmap
    document.getElementById('drawBtn').addEventListener('click', generateMindmap); 
    document.getElementById('downloadPng').addEventListener('click', downloadImage);
    document.getElementById('exportJson').addEventListener('click', exportJSON);
    document.getElementById('importFile').addEventListener('change', importJSON);
    document.getElementById('resetAll').addEventListener('click', resetAll);
    document.getElementById('clearStorage').addEventListener('click', ()=>{ if(confirm('Supprimer la sauvegarde locale ?')) { localStorage.removeItem(STORAGE_KEY); showMessage('Sauvegarde supprim√©e','success'); } });
    document.getElementById('loadExample').addEventListener('click', loadExample);
    document.getElementById('gardenMode').addEventListener('click', loadGardenMode);

    ensureCanvas(); // pointer events on canvas
    if(canvas){ 
        canvas.addEventListener('pointerdown', onPointerDown); 
        window.addEventListener('pointermove', onPointerMove); 
        window.addEventListener('pointerup', onPointerUp); 
        canvas.addEventListener('wheel', onWheel, { passive:false }); 
        canvas.addEventListener('contextmenu', (e)=>e.preventDefault()); 
        
        // S'assurer que le centre a une position de d√©part au chargement
        const centerPos = data.positions['center'];
        if (!centerPos) {
            data.positions['center'] = { x: canvas.width/2, y: canvas.height/2 };
            saveData();
        }
    }

    loadData(); 
    // Redimensionnement initial du canvas
    const container = document.getElementById('canvas-container'); 
    const rect = container.getBoundingClientRect(); 
    const dpr = window.devicePixelRatio || 1; 
    canvas.width = Math.max(800, Math.min(2000, Math.floor(rect.width * dpr)));
    canvas.height = Math.max(500, Math.floor((rect.height||700) * dpr));
    
    if(data.center) setTimeout(()=>{ try{ generateMindmap(); }catch(e){ console.error(e); } },200);
});

// auto save
window.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveData(); });
setInterval(saveData,2000);

</script>
</body>
</html>